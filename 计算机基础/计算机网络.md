# 计算机网络

# 计算机网络的分层

## 为什么网络要分层

1. **各层之间相互独立**：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）**。这个和我们对开发时系统进行分层是一个道理。**
2. **提高了整体灵活性** ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。**这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。**
3. **大问题化小** ： 分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 **这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。**

## OSI七层模型

![OSI七层模型](https://upyun.xuqiming.tech/knhub/osi-model-detail.1e3522a7.png)

## TCP/IP四层模型

TCP/IP四层自顶向下依次是应用层、传输层、网络层和网际接口层。

如下图为与OSI七层的简单对应关系。

![TCP/IP四层模型](https://upyun.xuqiming.tech/knhub/TCP-IP-4-model.0d44f92d.png)

# 应用层

**应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。**

## HTTP与HTTPS的区别

- **端口号** ：HTTP 默认是 80，HTTPS 默认是 443。

- **URL 前缀** ：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。

- **安全性和资源消耗** ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。

## SSL/TLS 的工作原理

SSL/TLS 的核心要素是**非对称加密**。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。（**公钥加密，私钥解密**）

使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际对消息的加密使用的是对称加密。

使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。

![SSL/TLS通信过程](https://upyun.xuqiming.tech/knhub/symmetric-encryption.5ce5ec47.png)

为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的**电子签名**。

当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。

## 应用层常见的协议及端口号

- HTTP:超文本传输协议
- SMTP:简单邮件传输(发送)协议
- POP3/IMAP:邮件接收的协议
-  FTP:文件传输协议
-  SSH:安全的网络传输协议

| 应用               | 应用层协议 | 端口号  | 传输层协议 | 备注                        |
| ------------------ | ---------- | ------- | ---------- | --------------------------- |
| 域名解析           | DNS        | 53      | UDP/TCP    | 长度超过 512 字节时使用 TCP |
| 动态主机配置协议   | DHCP       | 67/68   | UDP        |                             |
| 简单网络管理协议   | SNMP       | 161/162 | UDP        |                             |
| 文件传送协议       | FTP        | 20/21   | TCP        | 控制连接 21，数据连接 20    |
| 远程终端协议       | TELNET     | 23      | TCP        |                             |
| 安全的网络传输协议 | SSH        | 22      | TCP        |                             |
| 超文本传送协议     | HTTP       | 80      | TCP        |                             |
| 简单邮件传送协议   | SMTP       | 25      | TCP        |                             |
| 邮件读取协议       | POP3       | 110     | TCP        |                             |
| 网际报文存取协议   | IMAP       | 143     | TCP        |                             |

## 从输入URL到页面加载发生了什么🌟

参考：https://segmentfault.com/a/1190000006879700

总体来说分为以下几个过程:

1. DNS 解析
2. TCP 连接
3. 发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. 连接结束

具体过程：

### 1.**DNS解析过程**

1. 浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址，如果有，解析结束。同时域名被缓存的时间也可通过TTL属性来设置。
2. 如果浏览器缓存中没有（专业点叫还没命中），浏览器会检查操作系统缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在windows中可通过c盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的ip地址，那浏览器会首先使用这个ip地址。
3. 如果至此还没有命中域名，才会真正的请求本地域名服务器（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。
4. 如果LDNS仍然没有命中，就直接跳到Root Server 域名服务器请求解析
5. 根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址
6. 此时LDNS再发送请求给上一步返回的gTLD
7. 接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器
8. Name Server根据映射关系表找到目标ip，返回给LDNS
9. LDNS缓存这个域名和对应的ip
10. LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束

### 2.TCP连接过程

- 传输层：
  1. 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。
  2. 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。
  3. HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。
  4. 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。

- 网络层：建立TCP协议时，需要发送数据，发送数据在网络层使用IP协议，搜索对方的地址，一边中转一边发送；IP数据包在路由器之间传送时，路由选择使用OSPF协议。

- 网际接口层：路由器在与服务器通信时，使用ARP协议将IP地址转换为MAC地址。

### 3.发送 HTTP 请求

HTTP请求报文是由三部分组成: **请求行**, **请求报头**和**请求正文**。报文结构为：

- 第一行是包含了请求方法、URL、协议版本；
- 接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。
- 一个空行用来分隔首部和内容主体 Body
- 最后是请求的内容主体

```http
GET http://www.example.com/ HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cache-Control: max-age=0
Host: www.example.com
If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT
If-None-Match: "3147526947+gzip"
Proxy-Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 xxx

param1=1&param2=2
```

[HTTP请求方法](计算机基础/计算机网络?id=HTTP请求方法)

### 4.服务器处理请求并返回HTTP报文
响应报文结构：
- 第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了
- 接下来多行也是首部内容
- 一个空行分隔首部和内容主体
- 最后是响应的内容主体

```http
HTTP/1.1 200 OK
Age: 529651
Cache-Control: max-age=604800
Connection: keep-alive
Content-Encoding: gzip
Content-Length: 648
Content-Type: text/html; charset=UTF-8
Date: Mon, 02 Nov 2020 17:53:39 GMT
Etag: "3147526947+ident+gzip"
Expires: Mon, 09 Nov 2020 17:53:39 GMT
Keep-Alive: timeout=4
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Proxy-Connection: keep-alive
Server: ECS (sjc/16DF)
Vary: Accept-Encoding
X-Cache: HIT

<!doctype html>
<html>
<head>
    <title>Example Domain</title>
    // 省略... 
</body>
</html>
```

[HTTP请求常见的状态码](计算机基础/计算机网络?id=HTTP请求常见的状态码)

### 5.浏览器解析渲染页面

涉及到的主要协议：
- DNS：获取域名对应IP
- TCP：与服务器建立TCP连接
- IP：建立TCP协议时，需要发送数据，发送数据在网络层使用IP协议
- OSPF：IP数据包在路由器之间，路由选择使用OSPF协议
- ARP：路由器在与服务器通信时，需要将IP地址转换为MAC地址，需要使用ARP协议
- HTTP：在TCP建立完成后，使用HTTP协议访问网页

## HTTP请求方法

| 请求方法 | 含义 | 备注 |
| --- | ----- | --------- |
| GET | 获取资源 | 当前网络请求中，绝大部分使用的是 GET 方法。 |
| POST | 传输实体主体 | POST 主要用来传输数据，而 GET 主要用来获取资源。 |
| HEAD | 获取报文首部 | 和 GET 方法类似，但是不返回报文实体主体部分。<br/>主要用于确认 URL 的有效性以及资源更新的日期时间等。 |
| PUT | 上传文件 | 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 |
| DELETE | 删除文件 | 与 PUT 功能相反，并且同样不带验证机制。 |
| PATCH | 对资源进行部分修改 | PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 |
| OPTIONS | 查询支持的方法 | 查询指定的 URL 能够支持的方法。<br/>会返回 `Allow: GET, POST, HEAD, OPTIONS` 这样的内容。 |
| CONNECT | 要求在与代理服务器通信时建立隧道 | 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 |
| TRACE | 追踪路径 | 服务器会将通信路径返回给客户端。<br/>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。<br/>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。 |

## HTTP请求常见的状态码

|      | 类别                             | 原因短语                   |
| ---- | -------------------------------- | -------------------------- |
| 1XX  | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX  | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX  | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX  | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX  | Server Error（服务器错误状态码） | 服务器处理请求出错         |

# 传输层

**传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。** 

## TCP和UDP协议的区别

![TCP、UDP的区别](https://upyun.xuqiming.tech/knhub/tcp-vs-udp.png)

## TCP三次握手和四次挥手🌟

https://blog.csdn.net/qzcsu/article/details/72861891

### TCP三次握手的过程

- 客户端–发送带有 SYN 标志的数据包–一次握手–服务端
- 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端
- 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端

![三次握手](https://upyun.xuqiming.tech/knhub/0c9f470819684156cfdc27c682db4def.png)

### 为什么要三次握手

三次握手的目的是**建立可靠的通信信道**，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是**双方确认自己与对方的发送与接收是正常的**。

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常

第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常

第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

所以三次握手就能确认双发收发功能都正常，缺一不可。

### TCP四次挥手的过程

- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送

- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号

- 服务器-关闭与客户端的连接，发送一个 FIN 给客户端

- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1进行发送，服务器收到并确认后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。

![四次挥手](https://upyun.xuqiming.tech/knhub/四次挥手.png)

### 为什么客户端最后还要等待2MSL？

1. 保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

2. 防止“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

### 为什么建立连接是三次握手，关闭连接确是四次挥手呢？

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，**把ACK和SYN放在一个报文**里发送给客户端。
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方**ACK和FIN一般都会分开发送**，从而导致多了一次。

## TCP协议如何保证可靠传输

1. 应用数据被分割成 TCP 认为最适合发送的数据块。
2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4. TCP 的接收端会丢弃重复的数据。
5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是**可变大小的滑动窗口协议**。 （TCP 利用滑动窗口实现流量控制）
6. **拥塞控制：** 当网络拥塞时，减少数据的发送。TCP 的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。
7. **ARQ（自动重传请求） 协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

# 网络层

**网络层负责为分组交换网上的不同主机提供通信服务。**

## IP地址的分类

- A类地址：以0开头，第一个字节范围：0~127；
- B类地址：以10开头，第一个字节范围：128~191；
- C类地址：以110开头，第一个字节范围：192~223；
- D类地址：以1110开头，第一个字节范围为224~239；
- E类地址：以1111开头，保留地址

## 什么是ARP协议 (Address Resolution Protocol)

**ARP协议完成了IP地址与物理地址的映射**。

每一个主机都设有一个 ARP 高速缓存，里面有**所在的局域网**上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就向**所在的局域网**发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。

如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。

# 网络接口层

我们可以把网络接口层看作是数据链路层和物理层的合体。

1. **数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。**
2. **物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异**

## 网络接口层设备的概念

- 网卡：网卡是电脑的一个接收信息、转换信息、暂储信息的一个硬件。它是把接受到信息递交给上层，如（CUP）的一个接口。

- 网桥：网桥工作在数据链路层，将两个LAN（局域网）连起来，根据MAC地址来转发帧，可以看作一个“低层的路由器”（路由器工作在网络层，根据网络地址如IP地址进行转发）。
- 交换机：交换机是主导网络系统的集线设备，大部分交换机是在数据链路层（第二层）操作。 
